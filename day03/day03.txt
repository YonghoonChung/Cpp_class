클래스 : 객체의 속성(구조체, 필드, 변수)과 행동(함수)을 정의함
    객체1 + 객체2 + 객체3 + ... = 클래스

    유일한 특성과 상태 그리고 행동을 가지고 있다.

예) circle
    반지름: 속성
    면적 : 행동, 함수

    
    Circle  (template, 원본, 비어있는 그릇)
    radius;
    area();

        Circle 1        Circle 2        Circle 3  ...
        -------         -------         ------
radius: 1.0             2.0             10
area :  area()          area()          area()

템플릿

Circle의 복사본은 Circle1, Circle2, Circle3 이다
객체/object는 클래스/class의 인스턴스/instance(복사본)다
    객체 == 인스턴스

C++의 메인은 객체이다.
    클래스는 비어있다. -> 클래스는 결국 객체이다...

UML 표기법
-------------------------------------
|          Circle (클래스)          |
-------------------------------------
|    + radius : double              | ---------- 멤버 변수(필드)
-------------------------------------
|    + area() : double              |
|      Circle()                     | ---------- 멤버 함수
|    + Circle(radius : double)      |           ()
|                                   |
-------------------------------------

  +     : public 
  +(X)  : private

-------------------------------------
|   Circle1 : Circle    (인스턴스)   |
-------------------------------------
|          radius = 52.5            |
-------------------------------------

C :
int main (void){

}

C++ : 
class Circle {
public:
    double radius // public이다. public으로 만들기 위해서는 매번 붙여줘야한다.
}

int main(void){
    Circle circle1; // 자바에서는 Circle circle1 = new Circle();
    return 0;
}

생성자 -> 함수와 같은 기능이지만, 리턴이 없다.
    객체를 생성해준다.
    객체의 멤버 필드를 초기화 한다.

    사용 : 클래스명()

    사용은 멤버 필드와 멤버 변수 사이에 선언한다.

함수 -> 리턴이 존재한다

포인터 사용하는 객체
    dynCar->speed (이해 못합니다...)

    Car myCar vs Car *dynCar = new Car
        Car *dynCar = new Car -> 동적 객체 생성

    동적객체를 생성할 시 new 라는 키워드에 의해 생성시 포인터를 사용한다

    항상 delete를 사용해서 동적객체를 삭제한다.

C++에는 소멸자가 있다(Java와 다른점)
    ~ 를 사용

접근제어자는 생략을 안하는 것이 좋다
    가독성을 위해

get/set 함수 : private로 선언된 멤버 필드에 접근하여 데이터를 수정할 수 있다.
                멤버 변수를 사용하지 않고 멤버 함수를 통해서 접근하기 때문에 간접 접근이라고 할 수 있다.
    정보의 은닉화를 하기위해
    module 